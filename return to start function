//need to be global variables
char moves[3];
int numMoves ;

//simplifies path to obtain optimal approach route
void simplifyPath()
{
	// only simplify path if the second-to-last move was a 'B'
	if(numMoves < 3 || moves[numMoves-2] != 'B')
		return;

	int totalAngle = 0;
	int i;

	for(i = 1; i <= 3; i++)
	{
		switch(moves[numMoves - i])
		{
		case 'R':
			totalAngle += 90;
			break;

		case 'L':
			totalAngle += 270;
			break;

		case 'B':
			totalAngle += 180;
			break;
		}
	}

	// Get the angle as a number between 0 and 360 degrees.
	totalAngle = totalAngle % 360;

	// Replace all of those turns with a single one.
	switch(totalAngle)
	{
	case 0:
		moves[numMoves - 3] = 'S';
		break;

	case 90:
		moves[numMoves - 3] = 'R';
		break;

	case 180:
		moves[numMoves - 3] = 'B';
		break;

	case 270:
		moves[numMoves - 3] = 'L';
		break;
	}
	// The path is now two steps shorter.
	numMoves -= 2;
	
	//may need to replace last two steps with empty variables
	//must test this
}

//Reverses the path so that bot can return to initial position
void reverseMoves()
{
	int i;
	
	for(i = 0; i < numMoves; i++)
	{
		switch(moves[i])
		{
		case 'S':
			break;
			
		case 'R':
			moves[i] = 'L';
			break;

		case 'L':
			moves[i] = 'R';
			break;
		}
	}
}

//execution of revereseMoves
void unsolveMaze()
{
	int i;
	
	for(i = 1; i <= numMoves; i++)
	{
		switch(moves[numMoves - i])
		{
		case 'S':
			//move forward function
			break;
			
		case 'R':
			//move right function
			break;

		case 'L':
			//move left function
			break;
		}
	}
}
