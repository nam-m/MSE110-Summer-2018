#pragma config(Sensor, S1,     leftTouch,      sensorEV3_Touch)
#pragma config(Sensor, S2,     Ultra,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     Gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S4,     rightTouch,     sensorEV3_Touch)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float cell = 24; //cell length
int north = 0; //north
int east = 2; //east
int south = 3; //south
int west = 4; //west
//int n = -0.1; //speed modifier

int speed = -20;
int face = 0; //predefined face direction in maze
const int m = 0;
//Robot movements
void forward ()
{
	setMotorSyncTime(leftMotor, rightMotor, 0, 2100, speed);
	sleep(5000);
}
void left () //rotate left 90 deg
{
	setMotorSyncTime(leftMotor, rightMotor, -100, 1225, speed);
	sleep(500);
}
void right () //rotate right 90 deg
{
	setMotorSyncTime(leftMotor, rightMotor, 100, 1030, speed);
	sleep(5000);
}
void new_right ()
{
	resetGyro(Gyro);
	while ((getGyroDegrees(Gyro) <= 90) || (getGyroDegrees(Gyro) >= -90))
	{
		setMotorSpeed(leftMotor, speed);
    setMotorSpeed(rightMotor, -speed);
  }
  sleep (5000);
}
void turnover () //make 180 deg turn
{
	//clearTimer(T1);
	setMotorSyncTime(leftMotor, rightMotor, 100, 1270*2, speed);
	sleep(5000);
}

bool wall () //wall detection
{
	bool found = false;
	if (getUSDistance(Ultra) < cell)
		found = true;
	return found;
}

void left_turn (bool wall)
{
	//bool found = false;
	left();
	if (wall == false)
		forward();
	else
		right();
}

void right_turn (bool wall)
{
	bool found = false;
	right();
	if (wall == false)
		forward();
	else
	{
		right();
		forward();
	}
}

void go_straight (bool wall)
{
	if (wall == false)
		forward();
}
void mazeSolve (bool wall)
{
	left_turn (wall);
	go_straight (wall);
	right_turn (wall);
}
task main()
{
	while(true)
	{
		//mazeSolve(wall());
	//forward();
	right();
	}
}
