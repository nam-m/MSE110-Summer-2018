#pragma config(Sensor, S2,     Ultra,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     Color,          sensorEV3_Color)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int N = 0; //north
const int E = 1; //east
const int S = 2; //south
const int W = 3; //west
const int init_face = W; //predefined face direction in maze (N, S, E, or W)
const int init_x = 1; //initial x coordinates
const int init_y = 1; //initial y coordinates
const int end_x = 6; //ending x coordinates
const int end_y = 1; //ending y coordinates

const int n = 1; //speed modfier
const int straight = 1490;//# of encoder counts to traverse each cell //2500 for 5:1 ratio; 1490 for 3:1
const int turn = 585; //#of encoder counts to turn 90 deg //990 for 5:1 ratio; 585 for 3:1
const int backup = 440; //#of encoder counts to backup // 800 for 5:1 gear ratio; 440 for 3:1
const int wait = 250; //ms delay between each movement

//path optimization variables
char moves[50];
int numMoves = 1; //array iteration (yes I know arrays start at 0)
int count = 0; //number of potential bumps when returning to start

//play sound at 300 Hz for 2s
void sound()
{
	playTone(300, 200);
	sleep(2000);
}

//Robot movements
void forward()
{
	setMotorSyncEncoder(leftMotor, rightMotor, 0, straight, 100*n);
 	waitUntilMotorStop(leftMotor);
 	sleep(wait);
}

void left () //rotate left 90 deg
{
	setMotorSyncEncoder(leftMotor, rightMotor, 100, turn, -80*n);
	waitUntilMotorStop(leftMotor);
	sleep(wait);
}

void right() //rotate right 90 deg
{
	setMotorSyncEncoder(leftMotor, rightMotor, -100, turn, -80*n);
	waitUntilMotorStop(leftMotor);
	sleep(wait);
}

bool checkWall() //wall detection
{
	int wall = getUSDistance(Ultra);
	if (wall <= 20)
		return true;
	else
		return false;
}

void bumper()
{
	setMotorSyncTime(leftMotor, rightMotor, 0, 1800 , 100); //straighten self with wall for 1.8 seconds
	waitUntilMotorStop(leftMotor);
	//sleep(wait);

	setMotorSyncEncoder(leftMotor, rightMotor, 0, backup, -100);
	waitUntilMotorStop(leftMotor);
	//sleep(wait);
}

void calibrate ()
{	
	if (getUSDistance(S2)<= 20)
	{
		count++;
		if (count % 2 != 0)
			bumper();
	}
}

void simplifyMoves()
{
	// only simplify path if there are at least 3 moves or the second-to-last move was a 'B'
	if(numMoves < 3 || moves[numMoves-1] != 'B')
		return;

	int totalAngle = 0;
	int i;

	for(i = 0; i < 3; i++)
	{
		switch(moves[numMoves - i])
		{
		case 'L':
			totalAngle += 90;
			break;

		case 'R':
			totalAngle += 270;
			break;

		case 'B':
			totalAngle += 180;
			break;
		}
	}

	// Get the angle as a number between 0 and 360 degrees
	totalAngle = totalAngle % 360;

	// Replace all of those turns with a single one.
	switch(totalAngle)
	{
	case 0:
		moves[numMoves - 2] = 'S';
		break;

	case 90:
		moves[numMoves - 2] = 'L';
		break;

	case 180:
		moves[numMoves - 2] = 'B';
		break;

	case 270:
		moves[numMoves - 2] = 'R';
		break;
	}

	// after replacement, numMoves is now two steps shorter.
	numMoves -= 2;
}

void mazeSolve() //solves maze
{
	int x = init_x;
	int y = init_y;
	int face = init_face; //where bot currently faces
	int numTurns; // number of turns while in cell
	bool wall = false;
	bool bumpWall = false;

	while (x != end_x || y != end_y)
	{
		bumpWall = checkWall(); //check to see if there is wall in front of path

		right();
		numTurns = 1;

		if (face == W)
			face = N;
		else
			face ++;

		wall = checkWall();

		while (wall == true)
		{
			if (bumpWall == true && numTurns < 3) //will only bump wall twice
				bumper();

			left();

			if (face == N)
				face = W;
			else
				face --;

			numTurns++;
			wall = checkWall();
		}

		forward();

		//changes the x,y position of the robot
		switch (face)
		{
		case N:
			y++;
			break;

		case E:
			x++;
			break;

		case S:
			y--;
			break;

		case W:
			x--;
			break;
		}

		//creates the path of the robot
		switch (numTurns)
		{
		case 1:
			moves[numMoves] = 'R';
			break;

		case 2:
			moves[numMoves] = 'S';
			break;

		case 3:
			moves[numMoves] = 'L';
			break;

		case 4:
			moves[numMoves] = 'B';
			break;
		}
		simplifyMoves();

		numMoves++;
	}
	numMoves--; //removes extra empty move added at the end of above loop
}

void reverseMoves()
{
	int i;

	for(i = 1; i <= numMoves; i++)
	{
		switch(moves[i])
		{
		case 'S':
			break;

		case 'R':
			moves[i] = 'L';
			break;

		case 'L':
			moves[i] = 'R';
			break;
		}
	}
}

void unsolveMaze() //execution of revereseMoves
{
	int i;
	//180 and then forward
	right();
	right();
	forward();
	calibrate();

	//execute moves back to initial start
	for(i = 0; i < numMoves-1; i++)
	{
		switch(moves[numMoves - i])
		{
		case 'S':
			break;

		case 'R':
			right();
			break;

		case 'L':
			left();
			break;
		}
		
		forward();
		
		if (numMoves - i != 2)
			calibrate();
	}
}

task main()
{
	setMotorBrakeMode(motorA, motorBrake);
	setMotorBrakeMode(motorD, motorBrake);
	
	//start
	sound();
	mazeSolve();

	//found end
	sound();

	//back to start
	reverseMoves();
	unsolveMaze();
	sound();
}
