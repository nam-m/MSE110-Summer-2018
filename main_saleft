#pragma config(Sensor, S1,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     LeftRear,       sensorEV3_Touch)
#pragma config(Sensor, S3,     RightRear,      sensorEV3_Touch)
#pragma config(Sensor, S4,     Ultra,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          Left,          tmotorEV3_Large, openLoop, driveLeft, encoder)
#pragma config(Motor,  motorD,          Right,         tmotorEV3_Large, openLoop, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void reverse(float n)
{
	setMotorSyncEncoder(Left, Right, 0, 310*1.5 /*~15cm*/, -n*100); //reverse
	waitUntilMotorStop(Left);
	setMotorSyncEncoder(Left, Right, 100, 1350/2, n*100/*reverse*/);//Increase encoder values for 360 turn
	waitUntilMotorStop(Left);
	setMotorSync(Left, Right, 0, n*100);
}

void forward(float n, int left_rear, int right_rear)
{
	if (left_rear == 0 && right_rear == 0)
	{
		setMotorSync(Left, Right, 0, n*100);

		do{
			left_rear = getTouchValue(LeftRear);
			right_rear = getTouchValue(RightRear);
		}while(left_rear == 0 && right_rear == 0);
	}

	else if (left_rear == 0)
	{
		setMotorSpeed(Left, n*100);
		setMotorSpeed(Right, n*50);

		do{
			left_rear = getTouchValue(LeftRear);
		}while(left_rear == 0);
	}

	else
	{
		setMotorSpeed(Right, n*100);
		setMotorSpeed(Left, n*50);

		do{
			right_rear = getTouchValue(RightRear);
		}while(right_rear == 0);
	}

	setMotorSync(Left, Right, 0, 100*n);
}

bool search(float n, int motor_encoder, int distance, int light, int white)
{
	resetMotorEncoder(Left);
	motor_encoder = getMotorEncoder(Left);
	setMotorSyncEncoder(Left, Right, 100, 360, n*100);
	while (motor_encoder > -335)
	{
		distance = getUSDistance(Ultra);
		light = getColorName(Colour);

		if (distance <= 40)
		{
			setMotorSync(Left, Right, 0, 0);
			return true;
		}

		else if (light == white)
		{
			setMotorSync(Left, Right, 0, 0);
			return false;
		}

		motor_encoder = getMotorEncoder(Left);
	}

	resetMotorEncoder(Left);
	motor_encoder = getMotorEncoder(Left);
	setMotorSyncEncoder(Left, Right, -100, -720, n*100);
	while (motor_encoder < 695)
	{
		distance = getUSDistance(Ultra);
		light = getColorName(Colour);

		if (distance <= 40)
		{
			setMotorSync(Left, Right, 0, 0);
			return true;
		}

		else if (light == white)
		{
			setMotorSync(Left, Right, 0, 0);
			return false;
		}

		motor_encoder = getMotorEncoder(Left);
	}

	return false;
}

void attack (int distance, int light, int white, float n)//distance values TBD; if sensor is < 3cm, reading will be 255cm
{
	setMotorSync(Left, Right, 0, n*100);

	while (distance <= 40 && light != white)
	{
		distance = getUSDistance(Ultra);
		light = getColorName(Colour);

		if (light == white)
		{
			sleep(50);
			light = getColorName(Colour);
			displayCenteredBigTextLine(5, "Light: %d", light);
		}
	}

	if (light == 0)
	{
		setMotorSync(Left, Right, 0, 0);
		reverse(n);
	}


	else
		setMotorSync(Left, Right, 0, n*100);
}

task main()
{
	float n = -1; //speed/direction modifier
	int i = 1; //iteration for search
	int distance;
	int light;
	int white = 6; //
	int yellow = 4;
	int left_rear;
	int right_rear;
	bool obj_near = false;
	int motor_encoder;

	setMotorSyncEncoder(Left, Right, -100, 180 , n*100); //left turn from
	waitUntilMotorStop(Left);
	setMotorSyncEncoder(Left, Right, 0, 910*5/3, n*100);// overshoot?
	waitUntilMotorStop(Left);
	setMotorSyncEncoder(Left, Right, 100, 540 , n*100);
	waitUntilMotorStop(Left);

	setMotorSync(Left, Right, 0, n*100);

	while(true)
	{
		left_rear = getTouchValue(LeftRear);
		right_rear = getTouchValue(RightRear);
		light = getColorName(Colour); //light is TBD
		displayCenteredBigTextLine(5, "Light: %d", light);
		distance = getUSDistance(Ultra);

		if (distance <= 40)
			obj_near = true;

		if (light == white) //if on white line, reverse
		{
			sleep(50);
			light = getColorName(Colour);
			displayCenteredBigTextLine(5, "Light: %d", light);
			if (light == yellow) //if on yellow, 45 degree turn
			{
				setMotorSyncEncoder(Left, Right, -100, 360 , n*100); //left turn from
				waitUntilMotorStop(Left);
				setMotorSync(Left, Right, 0, n*100);
			}

			else reverse(n);
		}

		//if (left_rear == 0 || right_rear == 0)
		//	forward(n, left_rear, right_rear);


		//Swivel and search // swivel should have own function?

		else if (obj_near == false && i%10000 == 0)
		{
			obj_near = search(n, motor_encoder, distance, light, white);
			if (obj_near == false)
				setMotorSync(Left, Right, 0, n*100);
		}

		//attack
		if (obj_near == true)// || == 255 if sensor gets close enough
		{
			attack(distance, light, white, n);
			obj_near = false;
		}

		i++;
	}
}
