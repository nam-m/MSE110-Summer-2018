#pragma config(Sensor, S2,     Color,          sensorEV3_Color)
#pragma config(Sensor, S1,     Ultra,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          RightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          LeftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
task main()
{
	//Moving Objects Variables
	float ObjDist;
	int distance;
	int reverse;
	int time = 500;
	int a = 0; //iteration value
	int b = 0;
	float n = 0.5; //speed modifier, testing only

	float p = 1.8; // P constant
	float i = 0.005; // I constant
	float d = 10; // D constant
	float straight = 20; //power level to go straight when error = 0;
	int light_grade;
	int black = 52; //45-50
	int white = 8; //6-7
	int offset = (black + white)/2; //(target track edge) attempt to make it integer
	int integral = 0;
	int lastError = 0;
	int derivative = 0;
	int error;
	float speed;
	
	setMotorBrakeMode(LeftMotor,motorBrake);
	setMotorBrakeMode(RightMotor,motorBrake);
	
	while (true)
	{
		ObjDist = getUSDistance(Ultra);
		
/*Stop 10cm away and beep*/
		if (ObjDist <= 10 && a == 0)
		{
			setMotorSync(LeftMotor, RightMotor, 0, 0);
			sleep (2000);
			playSound(soundBeepBeep);
			sleep (500);
			a++;
  	}
		
  	
/*Move Object away from line*/
  	if (ObjDist <= 6)
		{
			//90 degree right turn
			setMotorSyncEncoder(LeftMotor, RightMotor, -50, 380, 100*n);
			waitUntilMotorStop(LeftMotor);
			resetMotorEncoder(LeftMotor);
			
			//Move 10cm; if object falls off edge, stop 
			//setMotorSyncEncoder(LeftMotor, RightMotor, 0, 205, 100*n);
			clearTimer(T1);
			
      setMotorSyncTime(LeftMotor, RightMotor, 0, 500, 100*n);
			
			do {
					light_grade = getColorReflected(Color);
					
					if (light_grade == 0)
					{
							setMotorSync(LeftMotor, RightMotor, 0, 0*n);
							time = time1[T1];
					}
					distance = getMotorEncoder(LeftMotor);
					
			}while (light_grade != 0 && distance < 205);

			//if stopped on line, move another 5cm; if object falls off edge, stop 
			while(light_grade != 0 && light_grade <= offset)
			{
			 		light_grade = getColorReflected(Color);
			 		
			 		if (light_grade == 0)
						setMotorSync(LeftMotor, RightMotor, 0, 0*n);

					else
					{
						setMotorSyncTime(LeftMotor, RightMotor, 0, 150, -100*n);
						b++;
					}	
				}
				
		//Return to intial Position  
		//reverse = getMotorEncoder(LeftMotor);
		//setMotorSyncEncoder(LeftMotor, RightMotor, 0, 10, -100*n);
		setMotorSyncTime(LeftMotor, RightMotor, 0, time+b*150, -100*n);
    waitUntilMotorStop(LeftMotor);
    setMotorSyncEncoder(LeftMotor, RightMotor, -50, -380, -100*n); //reverse 90 degree right turn
    waitUntilMotorStop(LeftMotor);
    
    a = 0;
    b = 0;
    time = 500;
		}
		
		light_grade = getColorReflected(Color);
		displayCenteredBigTextLine(2, "Color: %d", light_grade);
		error = light_grade - offset;
		integral = (2/3)* integral + error;
		derivative = error - lastError;
		speed = p*error + i*integral + d*derivative;
		setMotorSpeed(RightMotor, straight - speed);
		setMotorSpeed(LeftMotor, straight + speed);
		lastError = error;
		sleep(1);
	}
	
		
}
