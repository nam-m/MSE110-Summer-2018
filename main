#pragma config(Sensor, S2,     Color,          sensorEV3_Color)
#pragma config(Sensor, S1,     Ultra,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          RightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          LeftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
task main()
{
	//Moving Objects Variables
	float ObjDist;
	int distance;
	//int reverse;
	int time = 500;
	int a = 0; //iteration value
	int b = 0;
	float n = 0.5; //speed modifier, testing only
	//currently working with p = 1.8-2, d = 8, i = 0.005
	//suddenly able to turn at 60 deg angle with p = 3, d = 1-1.5
	float p = 2; // P constant 2
	float i = 0.5; // I constant 0.5
	float d = 7.5;  //D constant 7.5
	float straight = 20; //power level to go straight when error = 0;
	int light_grade;
	int black = 53; //45-50
	int white = 7; //6-7
	int offset = (black + white)/2; //(target track edge) attempt to make it integer
	int integral = 0;
	int lastError = 0;
	int derivative = 0;
	int error;
	float turn;

	setMotorBrakeMode(LeftMotor,motorBrake);
	setMotorBrakeMode(RightMotor,motorBrake);

	while (true)
	{
		ObjDist = getUSDistance(Ultra);

		/*Stop 10cm away and beep*/
		if (ObjDist <= 10 && a == 0)
		{
			setMotorSync(LeftMotor, RightMotor, 0, 0);
			sleep (2000);
			playSound(soundBeepBeep);
			sleep (500);
			a++;
		}

		/*Move Object away from line*/
		if (ObjDist <= 6)
		{
			//90 degree right turn
			setMotorSyncEncoder(LeftMotor, RightMotor, -50, 380, 100*n);
			waitUntilMotorStop(LeftMotor);
			resetMotorEncoder(LeftMotor);

			//Move 10cm; if object falls off edge, stop
			clearTimer(T1);

			setMotorSyncTime(LeftMotor, RightMotor, 0, 500, 100*n);

			do {
				light_grade = getColorReflected(Color);

				if (light_grade == 0)
				{
					setMotorSync(LeftMotor, RightMotor, 0, 0*n);
					time = time1[T1];
				}
				distance = getMotorEncoder(LeftMotor);

			}while (light_grade != 0 && distance < 205);

			//if stopped on line, move another 5cm; if object falls off edge, stop
			while(light_grade != 0 && light_grade <= offset)
			{
				light_grade = getColorReflected(Color);

				if (light_grade == 0)
					setMotorSync(LeftMotor, RightMotor, 0, 0*n);

				else
				{
					setMotorSyncTime(LeftMotor, RightMotor, 0, 150, -100*n);
					b++;
				}
			}

			//Return to intial Position
			setMotorSyncTime(LeftMotor, RightMotor, 0, time+b*150, -100*n);
			waitUntilMotorStop(LeftMotor);
			setMotorSyncEncoder(LeftMotor, RightMotor, -50, -380, -100*n); //reverse 90 degree right turn
			waitUntilMotorStop(LeftMotor);

			a = 0;
			b = 0;
			time = 500;
		}

		light_grade = getColorReflected(Color);
		displayCenteredBigTextLine(2, "Color: %d", light_grade);
		displayCenteredBigTextLine(5, "d: %d", derivative);
		displayCenteredBigTextLine(7, "i: %d", integral);
		error = light_grade - offset;
		integral = (1/4)* integral + error;
		derivative = error - lastError;
		turn = p*error + i*integral + d*derivative;
		setMotorSpeed(RightMotor, straight - turn - 0);
		setMotorSpeed(LeftMotor, straight + turn + 0);
		lastError = error;
		sleep(1);
	}


}
