#pragma config(Sensor, S1,     leftTouch,      sensorEV3_Touch)
#pragma config(Sensor, S2,     Ultra,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     rightTouch,     sensorEV3_Touch)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int N = 0; //north
const int E = 1; //east
const int S = 2; //south
const int W = 3; //west
const int init_face = 0; //predefined face direction in maze (N, S, E, or W)
const int init_x = 1; //initial x coordinates
const int init_y = 1; //initial y coordinates
const int end_x = 6; //ending x coordinates
const int end_y = 4; //ending y coordinates

const int n = -0.3; //speed modifier
const int straight = 1400;//# of ms counts to traverse each cell
const int turn = 680; //#of ms counts to turn 90 deg
const int backup = 380; //#of ms to backup

//path optimization variables
char moves[100];
int numMoves = 1; //array iteration (yes I know arrays start at 0)

//Robot movements
void forward()
{
	setMotorSyncTime(leftMotor, rightMotor, 0, straight ,100*n);
	waitUntilMotorStop(leftMotor);
}

void left() //rotate left 90 deg
{
	setMotorSyncTime(leftMotor, rightMotor, -100, turn, 100*n);//sign of turn TBD
	waitUntilMotorStop(leftMotor);
}

void right() //rotate right 90 deg
{
	setMotorSyncTime(leftMotor, rightMotor, 100, turn, 100*n);//sign of turn TBD
	waitUntilMotorStop(leftMotor);
}

bool checkWall() //wall detection
{
	if (getUSDistance(Ultra) <= 5)
		return true;
	else
		return false;
}

bool bumper()
{
		setMotorSyncTime(leftMotor, rightMotor, 0, 2000 , -50); //straighten self with wall
		sleep(1000);
		setMotorSyncTime(leftMotor, rightMotor, 0, backup ,100*n); //backup to middle
		sleep(1000);
}

void simplifyMoves()
{
	// only simplify path if there are at least 3 moves or the second-to-last move was a 'B'
	if(numMoves < 3 || moves[numMoves-1] != 'B')
		return;

	int totalAngle = 0;
	int i;

	for(i = 0; i < 3; i++)
	{
		switch(moves[numMoves - i])
		{
		case 'R':
			totalAngle += 90;
			break;

		case 'L':
			totalAngle += 270;
			break;

		case 'B':
			totalAngle += 180;
			break;
		}
	}

	// Get the angle as a number between 0 and 360 degrees.
	totalAngle = totalAngle % 360;

	// Replace all of those turns with a single one.
	switch(totalAngle)
	{
	case 0:
		moves[numMoves - 2] = 'S';
		break;

	case 90:
		moves[numMoves - 2] = 'R';
		break;

	case 180:
		moves[numMoves - 2] = 'B';
		break;

	case 270:
		moves[numMoves - 2] = 'L';
		break;
	}
	// The path is now two steps shorter.
	numMoves -= 2;

	//may need to replace last two steps with empty variables
	//must test this
}

void reverseMoves()
{
	int i;

	for(i = 0; i < numMoves; i++)
	{
		switch(moves[i])
		{
		case 'S':
			break;

		case 'R':
			moves[i] = 'L';
			break;

		case 'L':
			moves[i] = 'R';
			break;
		}
	}
}

//execution of revereseMoves
void unsolveMaze()
{
	int i;

	for(i = 1; i <= numMoves; i++)
	{
		switch(moves[numMoves - i])
		{
		case 'S':
			//move forward function
			break;

		case 'R':
			//move right function
			break;

		case 'L':
			//move left function
			break;
		}
	}
}

void mazeSolve() //solves maze
{
	int x = init_x;
	int y = init_y;
	int face = init_face; //where bot currently faces
	int numTurns; // number of turns while in cell
	bool wall = false;
	bool bumpWall = false;

	while (x != end_x && y != end_y)
	{
		bumpWall = checkWall();
		
		numTurns = 1;
		left();

		if (face == N)
			face = W;
		else
			face --;

		wall = checkWall();

		while (wall == true)
		{
			if (bumpWall == true && numTurns < 3)
				bumper();
		
			right();
			
			if (face == W)
				face = N;
			else
				face ++;

			numTurns++;
			wall = checkWall();
		}

		forward();
		
		//changes the x,y position of the robot
		switch (face)
		{
		case N:
			y++;
			break;

		case E:
			x++;
			break;

		case S:
			y--;
			break;

		case W:
			x--;
			break;
		}
		
		//creates the path of the robot 
		switch (numTurns)
		{
		case 1:
			moves[numMoves] = 'L';
			break;

		case 2:
			moves[numMoves] = 'S';
			break;

		case 3:
			moves[numMoves] = 'R';
			break;

		case 4:
			moves[numMoves] = 'B';
			break;
		}

		simplifyMoves();
		numMoves++;
	}
}

task main()
{
	playTone(300, 200);
	mazeSolve();
	playTone(300, 200);
	reverseMoves();
	unsolveMaze();
}
