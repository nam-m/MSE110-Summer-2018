#pragma config(Sensor, S1,     leftTouch,      sensorEV3_Touch)
#pragma config(Sensor, S2,     Ultra,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     rightTouch,     sensorEV3_Touch)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int N = 0; //north
const int E = 1; //east
const int S = 2; //south
const int W = 3; //west
const int init_face = 0; //predefined face direction in maze (N, S, E, or W)
const int init_x = 1; //initial x coordinates
const int init_y = 1; //initial y coordinates
const int end_x = 6; //ending x coordinates
const int end_y = 4; //ending y coordinates

const int n = 0.1; //speed modifier
const int distance = 100;//# of encoder counts to traverse each cell
const int turn = 100; //#of encoder counts to turn 90 deg

//path optimization variables
char moves[100];
int numMoves = 0;

//Robot movements
void forward()
{
	setMotorSyncEncoder(leftMotor, rightMotor, 0, distance ,100*n);
	waitUntilMotorStop(leftMotor);
}

void left() //rotate left 90 deg
{
	setMotorSyncEncoder(leftMotor, rightMotor, -100, turn, 100*n);//sign of turn TBD
	waitUntilMotorStop(leftMotor);
}

void right() //rotate right 90 deg
{
	setMotorSyncEncoder(leftMotor, rightMotor, 100, -turn, 100*n);//sign of turn TBD
	waitUntilMotorStop(leftMotor);
}

bool checkWall() //wall detection
{
	bool found = false;

	if (getUSDistance(Ultra) <= 5)
		found = true;
	else
		return found;
}

void simplifyMoves()
{
	// only simplify path if there are at least 3 moves or the second-to-last move was a 'B'
	if(numMoves < 3 || moves[numMoves-2] != 'B')
		return;

	int totalAngle = 0;
	int i;

	for(i = 1; i <= 3; i++)
	{
		switch(moves[numMoves - i])
		{
		case 'R':
			totalAngle += 90;
			break;

		case 'L':
			totalAngle += 270;
			break;

		case 'B':
			totalAngle += 180;
			break;
		}
	}

	// Get the angle as a number between 0 and 360 degrees.
	totalAngle = totalAngle % 360;

	// Replace all of those turns with a single one.
	switch(totalAngle)
	{
	case 0:
		moves[numMoves - 3] = 'S';
		break;

	case 90:
		moves[numMoves - 3] = 'R';
		break;

	case 180:
		moves[numMoves - 3] = 'B';
		break;

	case 270:
		moves[numMoves - 3] = 'L';
		break;
	}
	// The path is now two steps shorter.
	numMoves -= 2;

	//may need to replace last two steps with empty variables
	//must test this
}

void mazeSolve() //returns array of char with list of direction
{

	int i = 0; //array iterator
	int x = init_x;
	int y = init_y;
	int face = init_face; //where bot currently faces
	int numTurns; // number of turns while in cell
	bool wall = false;

	while (x != end_x && y != end_y)
	{
		numTurns = 1;
		left();

		if (face == N)
			face = W;
		else
			face --;

		wall = checkWall();

		while (wall == false)
		{
			right();
			if (face == W)
				face = N;
			else
				face ++;

			numTurns++;
			wall = checkWall();
		}

		forward();
		
		//changes the x,y position of the robot
		switch (face)
		{
		case N:
			y++;
			break;

		case E:
			x++;
			break;

		case S:
			y--;
			break;

		case W:
			x--;
			break;
		}
		
		//creates the path of the robot 
		switch (numTurns)
		{
		case 1:
			moves[numMoves] = 'L';
			break;

		case 2:
			moves[numMoves] = 'S';
			break;

		case 3:
			moves[numMoves] = 'R';
			break;

		case 4:
			moves[numMoves] = 'B';
			break;
		}

		simplifyMoves();
		numMoves++;
	}
}
