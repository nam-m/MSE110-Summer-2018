#pragma config(Sensor, S1,     leftTouch,      sensorEV3_Touch)
#pragma config(Sensor, S2,     Ultra,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     rightTouch,     sensorEV3_Touch)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float cell = 10; //cell length (cell is a square)
const int N = 0; //north
const int E = 1; //east
const int S = 2; //south
const int W = 3; //west
const int n = 0.1; //speed modifier
const int distance = 100;//# of encoder counts to traverse each cell
const int turn = 100; //#of encoder counts to turn 90 deg

const int face = 0; //predefined face direction in maze
const int start_x = 1; //starting x coordinates
const int start_y = 1; //starting y coordinates
const int end_x = 6; //ending x coordinates
const int end_y = 4; //ending y coordinates

//Robot movements
void forward()
{
	setMotorSyncEncoder(leftMotor, rightMotor, 0, distance ,100*n);
}
void left() //rotate left 90 deg
{
	setMotorSyncEncoder(leftMotor, rightMotor, -100, turn, 100*n);//sign of turn TBD
}
void right() //rotate right 90 deg
{
	setMotorSyncEncoder(leftMotor, rightMotor, 100, -turn, 100*n);//sign of turn TBD
}
void backward() //make 180 deg turn
{

	setMotorSyncTime(leftMotor, rightMotor, 100, turn*2, 20);
}

bool wall() //wall detection
{
	bool found = false;

	if (getUSDistance(Ultra) <= 5)
		found = true;
	else
		return found;

char mazeSolve () //returns array of char with list of direction
{
	char movements[];

	while (start_x != end_x && start_y != end_y)
	{
		left();

		if face = N
			face = W;
		else
			face --;


	}

	wall();

	return movements;
}

task main()
{
	while(true)
	{
		//left wall follower
		mazeSolve();
		forward(n);
	}
}
