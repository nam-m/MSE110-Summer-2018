#pragma config(Sensor, S1,     rightTouch,     sensorEV3_Touch)
#pragma config(Sensor, S2,     Ultra,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     leftTouch,      sensorEV3_Touch)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int N = 0; //north
const int E = 1; //east
const int S = 2; //south
const int W = 3; //west
const int init_face = E; //predefined face direction in maze (N, S, E, or W)
const int init_x = 1; //initial x coordinates
const int init_y = 2; //initial y coordinates
const int end_x = 3; //ending x coordinates
const int end_y = 3; //ending y coordinates

const int n = -0.3; //speed modifier
const int straight = 2500;//# of ms counts to traverse each cell
const int turn = 990; //#of ms counts to turn 90 deg
const int backup = 380; //#of ms to backup

//path optimization variables
char moves[75];
int numMoves = 1; //array iteration (yes I know arrays start at 0)

//Robot movements
void forward()
{
	setMotorSyncEncoder(leftMotor, rightMotor, 0, straight, 100);
  waitUntilMotorStop(leftMotor);
	sleep(1000);
}

void left () //rotate left 90 deg
{
	setMotorSyncEncoder(leftMotor, rightMotor, 100, turn, -80); ////gear ratio 1:5
	//setMotorSyncEncoder(leftMotor, rightMotor, 100, 600, -100); //gear ratio 1:3
	waitUntilMotorStop(leftMotor);
	sleep(1000);
}

void right() //rotate right 90 deg
{
	setMotorSyncEncoder(leftMotor, rightMotor, -100, turn, -80); ////gear ratio 1:5
	//setMotorSyncEncoder(leftMotor, rightMotor, -100, 600, -100); //gear ratio 1:3
	waitUntilMotorStop(leftMotor);
	sleep(1000);
}

bool checkWall() //wall detection
{
	int wall = getUSDistance(Ultra);
	if (wall <= 15)
		return true;
	else
		return false;
}

void bumper()
{
	setMotorSyncTime(leftMotor, rightMotor, 0, 1800 , 100); //straighten self with wall
	//setMotorSyncEncoder(leftMotor, rightMotor, 0, 400, -30);
	waitUntilMotorStop(leftMotor);
	//sleep(1000);
	//setMotorSyncTime(leftMotor, rightMotor, 0, 300 ,30); //backup to middle
	setMotorSyncEncoder(leftMotor, rightMotor, 0, 800, -100);
	waitUntilMotorStop(leftMotor);
	sleep(300);
}

//void bumper()
//{
//	while (getTouchValue(leftTouch) == 0 || getTouchValue(rightTouch) == 0)
//	{
//		setMotorSync(leftMotor, rightMotor, 0, 100);
//		displayBigTextLine(1, "Left: %d", getTouchValue(leftTouch));
//		displayBigTextLine(3, "Right: %d", getTouchValue(rightTouch));
//	}

//	//setMotorSync(leftMotor, rightMotor, 0, 0);
//	sleep(1000);
//	//waitUntilMotorStop(rightMotor);

//	setMotorSyncEncoder(leftMotor, rightMotor, 0, 500, -100);
//	sleep(2000);
//	//waitUntilMotorStop(rightMotor);

//}

void simplifyMoves()
{
	// only simplify path if there are at least 3 moves or the second-to-last move was a 'B'
	if(numMoves < 3 || moves[numMoves-1] != 'B')
		return;

	int totalAngle = 0;
	int i;

	for(i = 0; i < 3; i++)
	{
		switch(moves[numMoves - i])
		{
		case 'R':
			totalAngle += 90;
			break;

		case 'L':
			totalAngle += 270;
			break;

		case 'B':
			totalAngle += 180;
			break;
		}
	}

	// Get the angle as a number between 0 and 360 degrees.
	totalAngle = totalAngle % 360;

	// Replace all of those turns with a single one.
	switch(totalAngle)
	{
	case 0:
		moves[numMoves - 2] = 'S';
		break;

	case 90:
		moves[numMoves - 2] = 'R';
		break;

	case 180:
		moves[numMoves - 2] = 'B';
		break;

	case 270:
		moves[numMoves - 2] = 'L';
		break;
	}
	// The path is now two steps shorter.
	numMoves -= 2;

	//may need to replace last two steps with empty variables
	//must test this
}

void mazeSolve() //solves maze
{
	bool i = false;
	int x = init_x;
	int y = init_y;
	int face = init_face; //where bot currently faces
	int numTurns; // number of turns while in cell
	bool wall = false;
	bool bumpWall = false;

	while (x != end_x || y != end_y)
	{
		bumpWall = checkWall();

		left();
		numTurns = 1;

		if (face == N)
			face = W;
		else
			face --;

		wall = checkWall();

		while (wall == true)
		{
			if (bumpWall == true && numTurns < 3)
				bumper();

			right();

			if (face == W)
				face = N;
			else
				face ++;

			numTurns++;
			wall = checkWall();
		}

		forward();

		//changes the x,y position of the robot
		switch (face)
		{
		case N:
			y++;
			break;

		case E:
			x++;
			break;

		case S:
			y--;
			break;

		case W:
			x--;
			break;
		}

		//creates the path of the robot
		switch (numTurns)
		{
		case 1:
			moves[numMoves] = 'L';
			break;

		case 2:
			moves[numMoves] = 'S';
			break;

		case 3:
			moves[numMoves] = 'R';
			break;

		case 4:
			moves[numMoves] = 'B';
			break;
		}
		//simplifyMoves();

		numMoves++;
	}
	numMoves--; //up for removal
}

void reverseMoves()
{
	int i;

	for(i = 1; i <= numMoves; i++)
	{
		switch(moves[i])
		{
		case 'S':
			break;

		case 'R':
			moves[i] = 'L';
			break;

		case 'L':
			moves[i] = 'R';
			break;
		}
	}
}

//execution of revereseMoves
void unsolveMaze()
{
	int i;
	right();
	right();
	//if (moves[numMoves] != 'S')	
	//forward();
	for(i = 0; i < numMoves; i++)
	{
		switch(moves[numMoves - i])
		{
		case 'S':
			forward();
			break;

		case 'R':
			right();
			forward();
			break;

		case 'L':
			left();
			forward();
			break;
		}
	}
}

task main()
{
	playTone(300, 200);
	sleep(2000);
	mazeSolve();
	setMotorSync(leftMotor,rightMotor,0,0);
	playTone(300, 200);
	sleep(2000);
	//forward();
	//right();
	//left();
	//bumper();
	
	reverseMoves();
	unsolveMaze();
	playTone(300, 200);
	sleep(2000);
}
